# План разработки CLI-утилиты анализа зависимостей Delphi

## Phase 1: MVP — Минимально рабочий прототип ✅ **ЗАВЕРШЕНО**

**Цель**: Создать базовую версию, которая может анализировать один Delphi проект и выводить список зависимостей.

### 1.1. Настройка проекта ✅
- [x] Создать .NET проект (Console Application)
- [x] Настроить структуру папок (Core, Parsers, Models, Output)
- [x] Настроить single-file publish в .csproj
- [x] Создать базовые модели данных (Project, Unit, Dependency)

### 1.2. Парсер .dproj файлов ✅
- [x] Реализовать DelphiProjectParser для чтения XML
- [x] Извлечение пути к главному .dpr файлу
- [x] Извлечение Search Paths из DCC_UnitSearchPath
- [x] Извлечение Include Paths
- [ ] Обработка переменных окружения и макросов ($(Platform), $(Config)) — *отложено в Phase 2*

### 1.3. Парсер Delphi исходников ✅
- [x] Создать DelphiSourceParser для .pas и .dpr файлов
- [x] Парсинг `uses` секций (interface и implementation)
- [x] Извлечение списка юнитов из uses
- [x] Базовая обработка комментариев (`//`, `{ }`, `(* *)`)
- [x] Парсинг директив `{$I}` и `{$INCLUDE}` для .inc файлов

### 1.4. Resolver путей к файлам ✅
- [x] Реализовать PathResolver
- [x] Поиск .pas файлов по имени юнита в search paths
- [x] Обработка qualified unit names (Vcl.Forms → Vcl\Forms.pas)
- [x] Поддержка относительных и абсолютных путей
- [x] Логика поиска в стандартных Delphi папках

### 1.5. Построение графа зависимостей ✅
- [x] Создать DependencyAnalyzer
- [x] Рекурсивный обход зависимостей (DFS)
- [x] Детекция циклических зависимостей (предотвращение бесконечной рекурсии)
- [x] Хранение уже обработанных файлов (HashSet)
- [x] Построение дерева/графа зависимостей

### 1.6. Вывод результатов ✅
- [x] Создать JsonOutputFormatter
- [x] Формирование структуры JSON с проектом, юнитами, includes
- [x] Сохранение в файл project.deps.json
- [x] Вывод в консоль (summary: количество юнитов, includes)
- [x] Базовая обработка ошибок и логирование

### 1.7. CLI интерфейс ✅
- [x] Парсинг аргументов командной строки (путь к .dproj)
- [x] Валидация входных параметров
- [x] Вывод справки (--help)
- [x] Обработка ошибок с понятными сообщениями

### 1.8. Тестирование MVP ✅
- [x] Создать тестовый Delphi проект (простой, 3-5 юнитов)
- [x] Протестировать на реальном проекте
- [x] Проверить корректность списка зависимостей
- [x] Валидация JSON выхода
- [x] Создать single-file executable
- [x] Создать README.md с документацией

---

## Phase 2: Optimization — Оптимизация производительности ✅ **ЗАВЕРШЕНО**

**Цель**: Ускорить работу для больших проектов, добавить кэширование и параллелизм.

### 2.1. Кэширование результатов ✅
- [x] Реализовать DependencyCache
- [x] Хэширование содержимого файлов (SHA256)
- [x] Сохранение кэша на диск (.deps-cache/cache.json)
- [x] Проверка актуальности кэша (по SHA256 хэшу)
- [x] Incremental анализ (перестроение только измененных файлов)
- [x] Статистика кэша (Cache Hits/Misses, Hit Rate)

### 2.2. Параллельный парсинг ✅
- [x] Внедрить Parallel.ForEach для парсинга файлов
- [x] Thread-safe коллекции для графа зависимостей (ConcurrentDictionary)
- [x] Синхронизация доступа к графу (lock)
- [x] Обработка исключений в параллельных задачах

### 2.3. Оптимизация I/O
- [x] Минимизация повторных чтений одного файла (через кэш)
- [ ] Асинхронное чтение файлов (async/await) — *отложено*
- [ ] Батчинг файловых операций — *не требуется*
- [ ] Использование Memory-mapped files — *не требуется для текущих объемов*

### 2.4. Профилирование ✅
- [x] Добавить метрики времени выполнения (PerformanceMetrics)
- [x] Измерение времени операций (Parse, Resolve, Analyze, Save)
- [x] Подсчет количества вызовов и среднего времени
- [x] CLI флаг --performance для вывода детальных метрик
- [x] Вывод процента времени для каждой операции

### 2.5. Улучшение парсера
- [ ] Оптимизация регулярных выражений — *отложено в Phase 3*
- [ ] Токенизация вместо regex — *не требуется на данном этапе*
- [ ] Пропуск ненужных секций кода — *отложено*
- [ ] Обработка больших файлов по частям — *не требуется для Pascal файлов*

---

## Phase 3: Production — Production-ready версия

**Цель**: Стабильная версия для использования в команде и CI/CD.

### 3.1. Расширенная функциональность
- [ ] Поддержка --changed-files (анализ только измененных файлов)
- [ ] Режим --watch (мониторинг изменений)
- [ ] Вывод в разных форматах (JSON, XML, CSV, DOT graph)
- [ ] Фильтрация вывода (--only-units, --only-includes)
- [ ] Verbose режим (--verbose, --debug)

### 3.2. Улучшенный парсинг Delphi
- [ ] Обработка условной компиляции ({$IFDEF}, {$IFNDEF}, {$ENDIF})
- [ ] Поддержка {$IFOPT} директив
- [ ] Корректная обработка строковых литералов
- [ ] Поддержка вложенных комментариев
- [ ] Edge cases: uses в generics, inline директивы

### 3.3. Обработка пакетов (packages)
- [ ] Парсинг .dpk файлов (Delphi package)
- [ ] Разрешение зависимостей через BPL
- [ ] Поддержка runtime/design-time packages

### 3.4. CI/CD интеграция
- [ ] Exit codes для успеха/ошибок
- [ ] Режим проверки (--verify): fail если зависимости изменились
- [ ] Генерация отчетов для CI (JUnit XML, HTML)
- [ ] Docker образ для CI pipelines

### 3.5. Детальное логирование
- [ ] Структурированное логирование (Serilog/NLog)
- [ ] Уровни логирования (Debug, Info, Warning, Error)
- [ ] Логирование в файл (--log-file)
- [ ] Диагностика проблем (какие файлы не найдены, почему)

### 3.6. Тестирование
- [ ] Unit тесты для всех компонентов
- [ ] Integration тесты на реальных проектах
- [ ] Тестовые fixtures (разные конфигурации Delphi проектов)
- [ ] Edge cases: большие проекты, циклы, отсутствующие файлы
- [ ] Code coverage > 80%

### 3.7. Документация
- [ ] README с примерами использования
- [ ] Документация API (если будет библиотека)
- [ ] Troubleshooting guide
- [ ] Contributing guide

### 3.8. Стабилизация
- [ ] Обработка всех исключений с понятными сообщениями
- [ ] Graceful degradation (если файл не найден, продолжить)
- [ ] Тестирование на больших монорепозиториях (1000+ файлов)
- [ ] Performance regression tests

---

## Критерии завершения фаз

### Phase 1 завершен, если:
- ✅ Утилита может проанализировать простой Delphi проект
- ✅ Генерируется корректный JSON с зависимостями
- ✅ Работает на тестовом проекте из 5-10 файлов

### Phase 2 завершен, если:
- ✅ Анализ проекта из 100 файлов < 5 секунд
- ✅ Повторный запуск с кэшем < 1 секунда
- ✅ Incremental анализ работает корректно

### Phase 3 завершен, если:
- ✅ Утилита работает на production монорепозитории
- ✅ CI интеграция настроена и работает
- ✅ Code coverage > 80%
- ✅ Документация завершена
- ✅ Нет критических багов

---

## Технический стек

- **Язык**: C# 10+
- **Framework**: .NET 6/7/8
- **Парсинг XML**: System.Xml.Linq
- **JSON**: System.Text.Json
- **CLI**: System.CommandLine (опционально)
- **Тесты**: xUnit/NUnit
- **Логирование**: Serilog (Phase 3)

---

## Приоритеты

1. **Phase 1** — критично, без этого ничего не работает
2. **Phase 2** — важно для usability в больших проектах
3. **Phase 3** — необходимо для production использования

Начинать следует с Phase 1, последовательно реализуя каждый пункт. Не переходить к Phase 2, пока Phase 1 полностью не завершен и протестирован.
